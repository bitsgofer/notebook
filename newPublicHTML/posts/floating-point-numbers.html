<!DOCTYPE html>
<html lang="en">



<head>
    <link rel="stylesheet" href="/assets/notebook.css">
	<link rel="icon" type="image/x-icon" href="/assets/favicon.ico"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
    <title>Bitsgofer</title>
</head>



<body>
<div id="root">
    
        
<header class="row">
    <a class="button col-sm col-md" href="/" target="">
        <span><strong>Bitsgofer</strong></span>
    </a>
	
    <a class="button hidden-sm col-md" href="/about" target="">
        <span>About</span>
    </a>
</header>

    


    <div class="row" id="doc-wrapper">
        <main class="col-sm-12 col-md-12 col-lg-12">
    
            

<div id="5ef0bb9b466ad0d8aed14c2bb734be97" class="card fluid">
	<h1 class="section double-padded">Floating point numbers</h1>

	<div class="section">

		<p>Recently, one of my colleagues tried to write the value <code>0.1</code> into <code>OpenTSDB</code> but got <code>0.100000001490116</code> when querying it back.</p>
<pre class="language-bash"><code class="language-bash">
$ echo "run OpenTSDB, listening on :4242"

$ echo "write 0.1"
$ curl -sX POST '127.0.0.1:/4242/api/put' \
        -H 'Content-Type: application/json' \
        -d '[{"metric":"test","tags":{"k":"v"},"timestamp":1523353120,"value":0.1}]' \
        -i
HTTP/1.1 204 No Content

$ echo "query back"
$ curl -sX POST '127.0.0.1:/4242/api/query' \
        -H 'Content-Type: application/json' \
        -d '{"start":1523353100,"end":1523353140,"queries":[{"metric":"test","tags":{"k":"v"},"aggregator":"none"}]}' \
        | json_pp
[
    {
        "aggregateTags": [],
        "metric": "test",
        "tags": {
            "k": "v"
        },
        "dps": {
            "1523353120": 0.100000001490116
        }
    }
]
</code></pre>
<p>The thus a series of WTF commenced.</p>
<p>Eventually, we figured out what happened, which was because <code>OpenTSDB 2.3.0</code>, the version we used, only use 32 bits to store the floating point numbers.</p>
<p>From the process, it seems there are some fundamental facts about floating point that engineers should know. There are many soures on this, such as: - <a href="https://dl.acm.org/citation.cfm?id=103163">What every computer scientist should know about floating-point arithmetic</a> <br/>or <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">alternative link</a> - <a href="https://ieeexplore.ieee.org/document/4610935/">IEEE 754-2008</a> <br/>or <a href="http://eng.umb.edu/~cuckov/classes/engin341/Reference/IEEE754.pdf">alternative link</a> - <a href="http://floating-point-gui.de" class="uri">http://floating-point-gui.de</a></p>
<p>However, I still feel those sources doesn't explain it clear enough for a confused person to understand. So this is another stab at it.</p>
<blockquote>
<p>Disclaimer: there's a lot of corner cases with floating point math, this article might miss them, still</p>
</blockquote>
<h1 id="tldr">TL,DR</h1>
<ol type="1">
<li>Most real numbers can't be stored accurately in a computer.</li>
<li>They get approximated, usually using a 32-bit or 64-bit representations.</li>
<li>Once approximated, you should round/truncate on display and comparison, but NEVER on calculation.</li>
<li>If you use either 32-bit or 64-bit, keep it consistent across your system.</li>
</ol>
<hr />
<h1 id="what-a-confused-programmers-should-remember-about-floating-point-numbers">What a confused programmers should remember about floating point numbers</h1>
<h2 id="terms">Terms</h2>
<ul>
<li><code>integers</code>: numbers with no decimal digits (e.g: <code>0</code>, <code>1</code>, <code>99999</code>, etc)</li>
<li><code>real numbers</code>: numbers in the set ℝ</li>
<li><code>floating point numers</code>: representation of a <code>real number</code> in computer, stored in <strong>N</strong> bits of memory</li>
<li><code>float</code>, <code>float32</code>: <code>floating point numbers</code> stored in <strong>32 bits</strong></li>
<li><code>double</code>, <code>float64</code>: <code>floating point numbers</code> stored in <strong>64 bits</strong></li>
</ul>
<h2 id="there-is-not-enough-bits-to-represent-real-numbers">1. There is not enough bits to represent real numbers</h2>
<p>Recall that when working with <code>integers</code>, you also have a limited range (e.g: <code>-128 - +127</code> for <code>int8</code>) due to bits limit. The same problem presents itself with <code>real numbers</code>, since you have to cram an infinite amount of numbers within ℝ into <strong>N bits</strong>.</p>
<p>Unlike <code>integers</code> where there is an exactly amount of numbers between 2 <code>integer</code> values, (e.g: only 1 number between <code>0</code> and <code>1</code>), there is an infinite amount of numbers between two <code>real numbers</code>. For example, between <code>0.0</code> and <code>0.1</code>, there can be <code>0.01</code>, <code>0.001</code>, <code>0.00000000001</code>, etc.</p>
<p>This means it's impossible to fit any range of <code>real numbers</code> into 32 or 64 bits.</p>
<h2 id="real-numbers-are-represented-using-3-integers-sign-significant-precision-and-exponent">2. Real numbers are represented using 3 integers: sign, significant precision and exponent</h2>
<p>Recall that you can express <code>integers</code> as sum of powers of 2, e.g:</p>
<pre class="language-bash"><code class="language-bash">
15 = 8 + 4 + 2 + 1 = 1 * 2^3 + 1 * 2^2 + 1 * 2^z + 1 * 2^0
</code></pre>
<p>Real numbers is also expressed in somewhat similar way:</p>
<pre class="language-bash"><code class="language-bash">
usually = (-1)^sign * 2^(exponent-1023) * 1.significant
or      = (-1)^sign * 2^-1022           * 0.significant        (very small numbers)
</code></pre>
<p>Basically, we partition the N bits into 3 parts to represent 3 integers: - sign - exponent - significant precision</p>
<p>The exact number of bits used per part are:</p>
<pre class="language-bash"><code class="language-bash">
| type    | sign | exponent | significant precision |
|---------|------|----------|-----------------------|
| 32-bit  |    1 |        8 |                    23 |
| 64-bit  |    1 |       11 |                    52 |
</code></pre>
<p>For example, in 64 bits format:</p>
<pre class="language-bash"><code class="language-bash">
| value  | sign | exponent    | significant precision                                |
|--------|------|-------------|------------------------------------------------------|
|    0.5 |    0 | 01111111110 | 0000000000000000000000000000000000000000000000000000 |
|        |    0 |        1022 |                                                    0 |
|--------|------|-------------|------------------------------------------------------|
|  -64.5 |    1 | 10000000101 | 0000001000000000000000000000000000000000000000000000 |
|        |    1 |        1029 |                                       35184372088832 |
|--------|------|-------------|------------------------------------------------------|
|  112.1 |    0 | 10000000101 | 1100000001100110011001100110011001100110011001100110 |
| approx |    0 |        1030 |                                     3384736594945638 |
</code></pre>
<h2 id="many-real-numbers-can-only-be-approximated-in-floating-point-format">3. Many real numbers can only be approximated in floating point format</h2>
<p>From the examples above, if you work the representation of 112.1 backwards, you will only get around <code>112.099999999999994315658113919</code>.</p>
<p>This represents the most critical part about <code>floating point numbers</code>: they are mostly approximations.</p>
<p>Unlike <code>integers</code>, most <code>floating point numbers</code> doesn't have an exact representation in binary systems. An iconic example is <code>0.1</code>, illustrated here:</p>
<pre class="language-go line-numbers"><code class="language-go">
func main() {
    fmt.Printf("%0.64f\n", 0.1) // 0.1000000000000000055511151231257827021181583404541015625000000000
}
</code></pre>
<h2 id="roundingtruncation-doesnt-help-with-retaining-precision">4. Rounding/truncation doesn't help with retaining precision</h2>
<p>During our confusion about <code>OpenTSDB</code>'s behavior, one of my colleagues suggested to round or truncate the result read, up to 5 decimal digits.</p>
<p>It seems to work, but actually is a bad way to deal with floating point numbers.</p>
<p>First, because there's no way you can represent <code>0.1</code>, rounding/truncating doesn't reall change this. You will get another approximated number.</p>
<p>Secondly, consider this code that simulate the effect of rounding.</p>
<pre class="language-go line-numbers"><code class="language-go">
package main

import (
    "fmt"

    "gonum.org/v1/gonum/floats"
)

func main() {
    var x float64 = 0.1

    const n = 5
    const precision = 5

    fmt.Println("multiply:")
    for i := 0; i < n; i++ {
        x = floats.Round(x, precision)
        x *= float64(0.1)
        fmt.Printf("%0.64f\n", x)
    }

    fmt.Println("divide:")
    for i := 0; i < n; i++ {
        x = floats.Round(x, precision)
        x /= float64(0.1)
        fmt.Printf("%0.64f\n", x)
    }

    fmt.Printf("%0.64f\n", x)
}
</code></pre>
<pre class="language-bash"><code class="language-bash">
multiply:
0.0100000000000000019428902930940239457413554191589355468750000000
0.0010000000000000000208166817117216851329430937767028808593750000
0.0001000000000000000047921736023859295983129413798451423645019531
0.0000100000000000000008180305391403130954586231382563710212707520
0.0000010000000000000001665063486394613434526945638936012983322144

divide:
0.0000000000000000000000000000000000000000000000000000000000000000
0.0000000000000000000000000000000000000000000000000000000000000000
0.0000000000000000000000000000000000000000000000000000000000000000
0.0000000000000000000000000000000000000000000000000000000000000000
0.0000000000000000000000000000000000000000000000000000000000000000
0.0000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Mathematically, you would expect to get <code>0.1</code> afterwards, but got <code>0</code> instead.</p>
<p>By rounding/truncating, you have lost more info in the <code>significant precision</code> bits (i.e: used less than the amount of available bits).</p>
<p>The bottom line is: if it's already a float, don't try to round/truncate it when doing computaion.</p>
<h2 id="however-roundingtruncate-help-when-you-are-displaying-and-comparing">5. However, rounding/truncate help when you are displaying and comparing</h2>
<p>Now, if the user enter <code>0.1</code> into your program, what should you display back? If you show them <code>0.1000000000000000055511151231257827021181583404541015625</code>, they will surely be suprised (everyone is trained in math, but not many knows how computer store numbers, sadly).</p>
<p>Hence, you will probably need to round this off so it looks like <code>0.1</code>.</p>
<p>Similarly, when you are comparing 2 expressions, they might be giving a <a href="https://www.urbandictionary.com/define.php?term=same%20same%20but%20different">&quot;same same but different&quot;</a> result.</p>
<blockquote>
<p>TODO(mark): lookup for an example to illustrate here</p>
</blockquote>
<p>You would also want to round/truncate things, upto a certain decimal digits there.</p>
<h2 id="keep-the-bit-size-consistent-across-your-system">6. Keep the bit size consistent across your system</h2>
<p>This is our problem when using <code>OpenTSDB 2.3.0</code>. Consider this flow:</p>
<ol type="1">
<li>User enter <code>0.1</code> in front-end code</li>
<li>Front-end encode <code>0.1</code> to JSON, sends to backend API</li>
<li>Backend API parse <code>0.1</code> in JSON, store as 64-bit approximation</li>
<li>Backend API encode the &quot;approximated&quot; <code>0.1</code> to JSON, sends to OpenTSDB via HTTP API</li>
<li>OpenTSDB parse <code>0.1</code> in JSON, <strong>store as 32-bit approximation</strong></li>
<li>OpenTSDB encode 32-bit approximated value of <code>0.1</code> into JSON and send to backend</li>
</ol>
<p>At step 5, our <code>OpenTSDB</code> breaks the convention. It truncates the significant precision bits.</p>
<p>When the result comes back and our backend try to store is value into 64-bit format, it thinks that is a different number. There would be no problem if everyone uses th IEEE standard for 64-bit <code>floating point numbers</code>.</p>
<p>This is an important point to remember when you write your own binary/JSON encoder/decoder (or anything that deals with binary representation, for that matter). You <strong>MUST</strong> conform to the standard to prevent nasty suprises.</p>
<p>We decided to upgrade our <code>OpenTSDB</code> to <code>2.4.0RC2</code>, because we do need 64-bit representation.</p>
<h2 id="floating-point-math-is-hard-read-plenty-articles">7. Floating point math is hard, read plenty articles</h2>
<p>Read the IEEE standard, blog posts from other people, run experiment with your code AND pen and paper.</p>
<p>Alaways be alert when it comes to floating point math :)</p>

		

	</div>
</div>

    


    
    
<footer style="text-align: center;">
	<p> All Rights Reserved, Tong Huu Khiem.</p>
</footer>

    
        </main>
    </div>
</div>



<script type="text/javascript" src="/assets/notebook.js"></script>



</body>
</html>
